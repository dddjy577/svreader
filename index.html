<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="SV-EN Reader">
    <title>Swedish Reader</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>
    
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; margin: 0; padding: 0; background: #f4f4f9; overflow: hidden; touch-action: none; }
        #controls { padding: 20px; text-align: center; background: white; box-shadow: 0 2px 5px rgba(0,0,0,0.1); position: relative; z-index: 10; height: 100vh; display: flex; flex-direction: column; justify-content: center; align-items: center;}
        #viewer { width: 100vw; height: 100vh; background: white; position: relative; overflow: hidden; }
        
        /* Floating Navigation Buttons */
        .nav-btn {
            position: absolute;
            bottom: 30px;
            width: 50px;
            height: 50px;
            background: rgba(44, 62, 80, 0.7);
            color: white;
            border-radius: 25px;
            display: none; /* Hidden until book loads */
            align-items: center;
            justify-content: center;
            font-size: 24px;
            z-index: 1000;
            cursor: pointer;
            backdrop-filter: blur(4px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        #prev-btn { left: 20px; }
        #next-btn { right: 20px; }
        .nav-btn:active { background: rgba(44, 62, 80, 1); transform: scale(0.95); }

        /* Translation Bubble */
        #translation-bubble {
            position: absolute;
            background: #2c3e50;
            color: #ecf0f1;
            padding: 12px 16px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 500;
            pointer-events: none;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s;
            z-index: 1000;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            max-width: 80vw;
            text-align: center;
        }
        #translation-bubble.visible { opacity: 1; visibility: visible; }
        .loading { font-style: italic; color: #bdc3c7; }
        input[type="file"] { font-size: 16px; padding: 10px; }
    </style>
</head>
<body>

    <div id="controls">
        <h2>üìñ Swedish Reader (v4)</h2>
        <input type="file" id="book-upload" accept=".epub" />
    </div>

    <div id="viewer"></div>
    
    <div id="prev-btn" class="nav-btn">‚ü®</div>
    <div id="next-btn" class="nav-btn">‚ü©</div>

    <div id="translation-bubble"></div>

    <script>
        const uploadInput = document.getElementById('book-upload');
        const bubble = document.getElementById('translation-bubble');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        let book, rendition;

        uploadInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (window.FileReader) {
                const reader = new FileReader();
                reader.onload = function(event) { loadBook(event.target.result); };
                reader.readAsArrayBuffer(file);
            }
        });

        function loadBook(bookData) {
            document.getElementById('viewer').innerHTML = '';
            book = ePub(bookData);
            rendition = book.renderTo("viewer", {
                width: "100%",
                height: "100%",
                spread: "none",
                flow: "paginated",
                manager: "default"
            });
            rendition.display();
            
            // Show the buttons!
            prevBtn.style.display = 'flex';
            nextBtn.style.display = 'flex';
            document.getElementById('controls').style.display = 'none';

            setupInteractions();
        }

        // Button Click Events
        prevBtn.addEventListener('touchstart', (e) => { e.preventDefault(); rendition.prev(); closeBubble(); });
        nextBtn.addEventListener('touchstart', (e) => { e.preventDefault(); rendition.next(); closeBubble(); });
        prevBtn.addEventListener('click', () => { rendition.prev(); closeBubble(); });
        nextBtn.addEventListener('click', () => { rendition.next(); closeBubble(); });

        function setupInteractions() {
            let tapTimer = null;
            let lastTapTime = 0;

            rendition.hooks.content.register(function(contents) {
                const iframeDoc = contents.document;

                iframeDoc.addEventListener('touchend', (e) => {
                    const touch = e.changedTouches[0];

                    if (iframeDoc.caretRangeFromPoint) {
                        const range = iframeDoc.caretRangeFromPoint(touch.clientX, touch.clientY);
                        
                        if (!range || range.startContainer.nodeType !== 3) {
                            closeBubble();
                            return;
                        }

                        const text = range.startContainer.nodeValue;
                        const offset = range.startOffset;
                        
                        const isLetter = (char) => /[a-zA-Z√•√§√∂√Ö√Ñ√ñ√©√â\-]/.test(char);
                        if (!text[offset] || !isLetter(text[offset])) {
                            closeBubble();
                            return;
                        }
                        
                        let start = offset;
                        let end = offset;
                        while (start > 0 && isLetter(text[start - 1])) start--;
                        while (end < text.length && isLetter(text[end])) end++;
                        
                        const word = text.slice(start, end).trim();
                        if (!word) return;

                        const sentenceText = range.startContainer.parentNode.innerText || text;
                        const sentence = extractSentence(sentenceText, word);

                        const iframeRect = document.querySelector('#viewer iframe').getBoundingClientRect();
                        const x = touch.clientX + iframeRect.left;
                        const y = touch.clientY + iframeRect.top - 20;

                        const currentTime = new Date().getTime();
                        const tapLength = currentTime - lastTapTime;
                        
                        if (tapLength < 350 && tapLength > 0) {
                            clearTimeout(tapTimer);
                            handleTranslation(sentence, x, y, true);
                            e.preventDefault(); 
                        } else {
                            tapTimer = setTimeout(() => {
                                handleTranslation(word, x, y, false);
                            }, 350);
                        }
                        lastTapTime = currentTime;
                    }
                });
            });
        }

        async function handleTranslation(textToTranslate, x, y, isSentence) {
            const prefix = isSentence ? "üìù " : "üîç ";
            showBubble(`${prefix}<span class='loading'>Translating...</span>`, x, y);

            try {
                const url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(textToTranslate)}&langpair=sv|en`;
                const response = await fetch(url);
                const data = await response.json();
                showBubble(`${prefix}${data.responseData.translatedText}`, x, y);
            } catch (error) {
                showBubble("Translation failed.", x, y);
            }
        }

        function showBubble(htmlText, x, y) {
            bubble.innerHTML = htmlText;
            let safeX = x;
            if (safeX < 120) safeX = 120;
            if (safeX > window.innerWidth - 120) safeX = window.innerWidth - 120;
            bubble.style.left = `${safeX}px`;
            bubble.style.top = `${y}px`;
            bubble.style.transform = 'translate(-50%, -100%)';
            bubble.classList.add('visible');
        }

        function closeBubble() {
            bubble.classList.remove('visible');
        }

        function extractSentence(paragraph, word) {
            const sentences = paragraph.match(/[^.!?]+[.!?]+/g) || [paragraph];
            const found = sentences.find(s => s.includes(word));
            return found ? found.trim() : word;
        }
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="SV-EN Reader">
    <title>Swedish Reader</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>
    
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; margin: 0; padding: 0; background: #f4f4f9; overflow: hidden; }
        #controls { padding: 20px; text-align: center; background: white; box-shadow: 0 2px 5px rgba(0,0,0,0.1); position: relative; z-index: 10; height: 100vh; display: flex; flex-direction: column; justify-content: center; align-items: center;}
        
        /* The Book Viewer */
        #viewer { width: 100vw; height: 100vh; background: white; position: relative; }
        
        /* Translation Bubble */
        #translation-bubble {
            position: absolute;
            background: #2c3e50;
            color: #ecf0f1;
            padding: 12px 16px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 500;
            pointer-events: none;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s;
            z-index: 1000;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            max-width: 80vw;
            text-align: center;
        }
        #translation-bubble.visible { opacity: 1; visibility: visible; }
        .loading { font-style: italic; color: #bdc3c7; }
        
        /* Styled Upload Button */
        input[type="file"] { font-size: 16px; padding: 10px; }
    </style>
</head>
<body>

    <div id="controls">
        <h2>üìñ Open a Swedish Book</h2>
        <input type="file" id="book-upload" accept=".epub" />
    </div>

    <div id="viewer"></div>
    <div id="translation-bubble"></div>

    <script>
        const uploadInput = document.getElementById('book-upload');
        const bubble = document.getElementById('translation-bubble');
        let book, rendition;

        // 1. Load the Book File
        uploadInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (window.FileReader) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    loadBook(event.target.result);
                };
                reader.readAsArrayBuffer(file);
            }
        });

        // 2. Render Book in Page-by-Page Mode (Kindle style)
        function loadBook(bookData) {
            document.getElementById('viewer').innerHTML = '';
            book = ePub(bookData);
            rendition = book.renderTo("viewer", {
                width: "100%",
                height: "100%",
                spread: "none",
                flow: "paginated", // This makes it page-by-page!
                manager: "default"
            });
            rendition.display();
            setupInteractions();
            
            document.getElementById('controls').style.display = 'none';
        }

        // 3. Handle Taps (Pages, Words, and Sentences)
        function setupInteractions() {
            let tapTimer = null;
            let lastTapTime = 0;

            rendition.hooks.content.register(function(contents) {
                const iframeDoc = contents.document;
                let touchStartX = 0;
                let touchStartY = 0;

                iframeDoc.addEventListener('touchstart', (e) => {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                });

                iframeDoc.addEventListener('touchend', (e) => {
                    const touch = e.changedTouches[0];
                    const distance = Math.sqrt(Math.pow(touch.clientX - touchStartX, 2) + Math.pow(touch.clientY - touchStartY, 2));
                    
                    // If user is swiping, ignore
                    if (distance > 10) return; 

                    const screenWidth = contents.window.innerWidth;
                    
                    // -- PAGE TURNING LOGIC --
                    // Tap left 20% of screen = Previous Page
                    if (touch.clientX < screenWidth * 0.2) {
                        rendition.prev();
                        closeBubble();
                        return;
                    }
                    // Tap right 20% of screen = Next Page
                    if (touch.clientX > screenWidth * 0.8) {
                        rendition.next();
                        closeBubble();
                        return;
                    }

                    // -- WORD SELECTION LOGIC (Middle 60% of screen) --
                    if (iframeDoc.caretRangeFromPoint) {
                        const range = iframeDoc.caretRangeFromPoint(touch.clientX, touch.clientY);
                        
                        // If they tapped blank space or image, just close bubble and stop
                        if (!range || range.startContainer.nodeType !== 3) {
                            closeBubble();
                            return;
                        }

                        const text = range.startContainer.nodeValue;
                        const offset = range.startOffset;
                        
                        // Check if tapped on actual letters (Swedish alphabet included)
                        const isLetter = (char) => /[a-zA-Z√•√§√∂√Ö√Ñ√ñ√©√â\-]/.test(char);
                        if (!text[offset] || !isLetter(text[offset])) {
                            closeBubble();
                            return;
                        }
                        
                        // Extract the exact word
                        let start = offset;
                        let end = offset;
                        while (start > 0 && isLetter(text[start - 1])) start--;
                        while (end < text.length && isLetter(text[end])) end++;
                        
                        const word = text.slice(start, end).trim();
                        if (!word) return;

                        // Extract the full sentence
                        const sentenceText = range.startContainer.parentNode.innerText || text;
                        const sentence = extractSentence(sentenceText, word);

                        // Find bubble coordinates
                        const iframeRect = document.querySelector('#viewer iframe').getBoundingClientRect();
                        const x = touch.clientX + iframeRect.left;
                        const y = touch.clientY + iframeRect.top - 20;

                        // -- SINGLE VS DOUBLE TAP TIMING --
                        const currentTime = new Date().getTime();
                        const tapLength = currentTime - lastTapTime;
                        
                        if (tapLength < 350 && tapLength > 0) {
                            // It's a Double Tap! (Translate Sentence)
                            clearTimeout(tapTimer);
                            handleTranslation(sentence, x, y, true);
                            e.preventDefault(); 
                        } else {
                            // It's a Single Tap! (Translate Word)
                            // We wait 350ms to see if they tap again before translating
                            tapTimer = setTimeout(() => {
                                handleTranslation(word, x, y, false);
                            }, 350);
                        }
                        lastTapTime = currentTime;
                    }
                });
            });
        }

        // 4. Fetch Translation
        async function handleTranslation(textToTranslate, x, y, isSentence) {
            // Add prefix so you know if it grabbed the word or sentence
            const prefix = isSentence ? "üìù " : "üîç ";
            showBubble(`${prefix}<span class='loading'>Translating...</span>`, x, y);

            try {
                const url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(textToTranslate)}&langpair=sv|en`;
                const response = await fetch(url);
                const data = await response.json();
                
                showBubble(`${prefix}${data.responseData.translatedText}`, x, y);
            } catch (error) {
                showBubble("Translation failed. Check internet.", x, y);
            }
        }

        // 5. Bubble UI & Text Helpers
        function showBubble(htmlText, x, y) {
            bubble.innerHTML = htmlText;
            
            // Keep bubble from going off screen
            let safeX = x;
            if (safeX < 120) safeX = 120;
            if (safeX > window.innerWidth - 120) safeX = window.innerWidth - 120;

            bubble.style.left = `${safeX}px`;
            bubble.style.top = `${y}px`;
            bubble.style.transform = 'translate(-50%, -100%)';
            bubble.classList.add('visible');
        }

        function closeBubble() {
            bubble.classList.remove('visible');
        }

        function extractSentence(paragraph, word) {
            // Better sentence splitting matching punctuation
            const sentences = paragraph.match(/[^.!?]+[.!?]+/g) || [paragraph];
            const found = sentences.find(s => s.includes(word));
            return found ? found.trim() : word;
        }
    </script>
</body>
</html>

